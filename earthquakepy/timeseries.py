import numpy as np
from .singledof import *


class TimeSeries:
    '''
    TimeSeries object class
    Defines time series
    '''
    def __init__(self, t, y):
        '''
        Time series object initiation with 
        t and y as lists or 1D arrays.
        If t is a scalar, then the array is 
        autogenerated with scalar value as dt.
        '''
        if (type(t) == float) or (type(t) == int):
            t = np.arange(0.0, len(y)*t-1E-5*t, t)
        self.t = t
        self.y = y

    def __repr__(self):
        #return str(pprint.PrettyPrinter(indent=2).pprint(vars(self)))
        #return str(vars(self))
        a = ""
        for key, val in vars(self).items():
            a += "{:10s}:{}\n".format(key, val)
        return a

    def set_tunit(self, unit):
        '''
        Set unit for T(time) coordinates.
        Unit should be a string.
        '''
        self.tunit = unit

    def set_yunit(self, unit):
        '''
        Set unit for y coordinates.
        Unit should be a string.
        '''
        self.yunit = unit

    def set_t(self, coords):
        '''
        Set T(time) coordinates.
        Should be a list or numpy array (1D)
        '''
        self.t = coords

    def set_eqname(self, name):
        ''' Set earthquake name '''
        self.eqName = name

    def set_eqdate(self, date):
        ''' Set earthquake date '''
        self.eqDate = date

    def set_station(self, station):
        ''' Recording station '''
        self.station = station

    def set_component(self, comp):
        ''' Directional component of record '''
        self.component = comp

    def set_dt(self, dt):
        ''' Time step between data points '''
        self.dt = dt

    def set_npts(self, npts):
        ''' Total number of points in the record '''
        self.npts = npts
        
    def set_time(self, time):
        ''' Total duration of the record in seconds'''
        self.time = time
    
    def set_filepath(self, filepath):
        ''' Record filepath '''
        self.filepath = filepath

    def get_response_spectra(self, Tstart=0.01, Tend=15.5, dT=1.0, xi=0.05):
        """
        Calculates linear elastic response spectra associated with the timeseries.
        Inputs:
        Tstart and Tend (floats): Periods corresponding to spectrum width
        dT (float): Step size for period
        xi (float): damping ratio
        """
        T = np.arange(Tstart, Tend, dT)
        specLength = len(T)
        Sd = np.empty(specLength)
        for i in range(specLength):
            s = Sdof(T=T[i], xi=xi)
            r = s.get_response(self, tsType="baseExcitation")
            D = np.max(np.abs(r.y[0]))
            Sd[i] = D
            #Sv = (2*np.pi/T)*Sd
            #Sa = (2*np.pi/T)*Sv
        return ResponseSpectra(T, Sd)

    def get_fourier_spectrum(self, graph=False):
        '''
        Computes fourier spectrum associated with the time series
        '''
        from scipy.fftpack import fft, fftfreq
        import matplotlib.pyplot as plt
        N = self.npts
        T = self.dt #sampling interval
        yf = fft(self.y)
        FAmp = np.abs(yf[0:N//2])
        freq = fftfreq(N, T)[:N//2]
        if graph: 
            fig, ax = plt.subplots()
            ax.plot(freq,  2.0/N *FAmp, color='black', linewidth=0.5)
            ax.set_xscale('log')
            plt.show()
        return FourierSpectrum(freq, FAmp)

    def get_power_spectrum(self, graph=False):
        '''
        Computes power spectrum associated with the time series
        '''
        N = self.npts
        fourier_spectrum = self.get_fourier_spectrum()
        freq = fourier_spectrum.frequencies
        powerAmp = fourier_spectrum.amplitude**2
        if graph: 
            fig, ax = plt.subplots()
            ax.plot(freq,  2.0/N *powerAmp, color='black', linewidth=0.5)
            ax.set_xscale('log')
            plt.show()
            
        return PowerSpectrum(freq, powerAmp)

    def mean_period(self):
        '''
        Computes the simplified frequency content characterisation parameter according to  Rathje et al. [1998]
        Returns
        -------
        Scalar:
            Mean period

        '''
        fourier_spectrum = self.get_fourier_spectrum()
        freq = fourier_spectrum.frequencies
        FAmp = fourier_spectrum.amplitude
        boolArr = (freq>0.25) & (freq<20)
        n = FAmp[boolArr]**2/freq[boolArr]
        n = n.sum()
        d = FAmp[boolArr]**2
        d = d.sum()
        return n/d

    def mean_frequency(self):
        '''
        Computes the simplified frequency content characterisation parameter according to  Schnabel [1973]
        Returns
        -------
        Scalar:
            Mean square frequency

        '''
        fourier_spectrum = self.get_fourier_spectrum()
        freq = fourier_spectrum.frequencies
        FAmp = fourier_spectrum.amplitude
        boolArr = (freq>0.25) & (freq<20)
        n = FAmp[boolArr]**2*freq[boolArr]
        n = n.sum()
        d = FAmp[boolArr]**2
        d = d.sum()
        return n/d

    def epsilon(self):
        '''
        Computes the dimensionless frequency indicator r$\epsilon$ accordingn to Clough and Penzien 
        Returns
        -------
        Scalar

        '''
        from scipy.integrate import trapz
        power_spectrum = self.get_power_spectrum()
        freq = power_spectrum.frequencies
        powerAmp = power_spectrum.amplitude
        m0 = trapz(powerAmp,freq)
        m2 = trapz(powerAmp*freq**2,freq)
        m4 = trapz(powerAmp*freq**4,freq)
        eps = np.sqrt(1 - m2**2/(m0*m4)) 
        return eps
    
class ResponseSpectra:
    def __init__(self, T, Sd):
        """
        Class for storing response spectra
        Inputs:
        T (array of float): Natural period
        Sd, Sv(not implemented), Sa(not implemented) (array of float): Spectral displacement, velocity and acceleration, respectively.
        """
        self.T = T
        self.Sd = Sd
        #self.Sv = Sv
        #self.Sa = Sa


class FourierSpectrum:
    def __init__(self, frequencies, amplitude):
        '''
        Class to store fourier spectra
        Parameters
        ----------
        Freqencies : Frequency (Hz)
        Amplitude : Fourier Amplitude
        '''
        self.frequencies = frequencies
        self.amplitude = amplitude
        

class PowerSpectrum:
    def __init__(self, frequencies, amplitude):
        '''
        Class to store power spectra
        Parameters
        ----------
        Freqencies : Frequency (Hz)
        Amplitude : Power Amplitude
        '''
        self.frequencies = frequencies
        self.amplitude = amplitude
